{"version":3,"file":"f4ec22b2e801f4347a4b.worker.js","mappings":"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","sources":["../../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../../node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../../node_modules/@babel/runtime/helpers/esm/construct.js","../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../../node_modules/comlink/src/comlink.ts","../../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../../lambda-calculus-interpreter/src/deshadow.ts","../../lambda-calculus-interpreter/src/printer.ts","../../lambda-calculus-interpreter/src/evaluator.ts","../../lambda-calculus-interpreter/src/parser/grammars/lambda-calc.pegjs","../../lambda-calculus-interpreter/src/parser/parsers.ts","../../lambda-calculus-interpreter/src/parser/index.ts","worker/parsing-worker.ts"],"sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct.bind();\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Endpoint,\n  EventSource,\n  Message,\n  MessageType,\n  PostMessageWithOrigin,\n  WireValue,\n  WireValueType,\n} from \"./protocol\";\nexport { Endpoint };\n\nexport const proxyMarker = Symbol(\"Comlink.proxy\");\nexport const createEndpoint = Symbol(\"Comlink.endpoint\");\nexport const releaseProxy = Symbol(\"Comlink.releaseProxy\");\n\nconst throwMarker = Symbol(\"Comlink.thrown\");\n\n/**\n * Interface of values that were marked to be proxied with `comlink.proxy()`.\n * Can also be implemented by classes.\n */\nexport interface ProxyMarked {\n  [proxyMarker]: true;\n}\n\n/**\n * Takes a type and wraps it in a Promise, if it not already is one.\n * This is to avoid `Promise<Promise<T>>`.\n *\n * This is the inverse of `Unpromisify<T>`.\n */\ntype Promisify<T> = T extends Promise<unknown> ? T : Promise<T>;\n/**\n * Takes a type that may be Promise and unwraps the Promise type.\n * If `P` is not a Promise, it returns `P`.\n *\n * This is the inverse of `Promisify<T>`.\n */\ntype Unpromisify<P> = P extends Promise<infer T> ? T : P;\n\n/**\n * Takes the raw type of a remote property and returns the type that is visible to the local thread on the proxy.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions.\n * See https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype RemoteProperty<T> =\n  // If the value is a method, comlink will proxy it automatically.\n  // Objects are only proxied if they are marked to be proxied.\n  // Otherwise, the property is converted to a Promise that resolves the cloned value.\n  T extends Function | ProxyMarked ? Remote<T> : Promisify<T>;\n\n/**\n * Takes the raw type of a property as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This is the inverse of `RemoteProperty<T>`.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions. See\n * https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype LocalProperty<T> = T extends Function | ProxyMarked\n  ? Local<T>\n  : Unpromisify<T>;\n\n/**\n * Proxies `T` if it is a `ProxyMarked`, clones it otherwise (as handled by structured cloning and transfer handlers).\n */\nexport type ProxyOrClone<T> = T extends ProxyMarked ? Remote<T> : T;\n/**\n * Inverse of `ProxyOrClone<T>`.\n */\nexport type UnproxyOrClone<T> = T extends RemoteObject<ProxyMarked>\n  ? Local<T>\n  : T;\n\n/**\n * Takes the raw type of a remote object in the other thread and returns the type as it is visible to the local thread\n * when proxied with `Comlink.proxy()`.\n *\n * This does not handle call signatures, which is handled by the more general `Remote<T>` type.\n *\n * @template T The raw type of a remote object as seen in the other thread.\n */\nexport type RemoteObject<T> = { [P in keyof T]: RemoteProperty<T[P]> };\n/**\n * Takes the type of an object as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This does not handle call signatures, which is handled by the more general `Local<T>` type.\n *\n * This is the inverse of `RemoteObject<T>`.\n *\n * @template T The type of a proxied object.\n */\nexport type LocalObject<T> = { [P in keyof T]: LocalProperty<T[P]> };\n\n/**\n * Additional special comlink methods available on each proxy returned by `Comlink.wrap()`.\n */\nexport interface ProxyMethods {\n  [createEndpoint]: () => Promise<MessagePort>;\n  [releaseProxy]: () => void;\n}\n\n/**\n * Takes the raw type of a remote object, function or class in the other thread and returns the type as it is visible to\n * the local thread from the proxy return value of `Comlink.wrap()` or `Comlink.proxy()`.\n */\nexport type Remote<T> =\n  // Handle properties\n  RemoteObject<T> &\n    // Handle call signature (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: UnproxyOrClone<TArguments[I]> }\n        ) => Promisify<ProxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: UnproxyOrClone<TArguments[I]>;\n            }\n          ): Promisify<Remote<TInstance>>;\n        }\n      : unknown) &\n    // Include additional special comlink methods available on the proxy.\n    ProxyMethods;\n\n/**\n * Expresses that a type can be either a sync or async.\n */\ntype MaybePromise<T> = Promise<T> | T;\n\n/**\n * Takes the raw type of a remote object, function or class as a remote thread would see it through a proxy (e.g. when\n * passed in as a function argument) and returns the type the local thread has to supply.\n *\n * This is the inverse of `Remote<T>`. It takes a `Remote<T>` and returns its original input `T`.\n */\nexport type Local<T> =\n  // Omit the special proxy methods (they don't need to be supplied, comlink adds them)\n  Omit<LocalObject<T>, keyof ProxyMethods> &\n    // Handle call signatures (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: ProxyOrClone<TArguments[I]> }\n        ) => // The raw function could either be sync or async, but is always proxied automatically\n        MaybePromise<UnproxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: ProxyOrClone<TArguments[I]>;\n            }\n          ): // The raw constructor could either be sync or async, but is always proxied automatically\n          MaybePromise<Local<Unpromisify<TInstance>>>;\n        }\n      : unknown);\n\nconst isObject = (val: unknown): val is object =>\n  (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n\n/**\n * Customizes the serialization of certain values as determined by `canHandle()`.\n *\n * @template T The input type being handled by this transfer handler.\n * @template S The serialized type sent over the wire.\n */\nexport interface TransferHandler<T, S> {\n  /**\n   * Gets called for every value to determine whether this transfer handler\n   * should serialize the value, which includes checking that it is of the right\n   * type (but can perform checks beyond that as well).\n   */\n  canHandle(value: unknown): value is T;\n\n  /**\n   * Gets called with the value if `canHandle()` returned `true` to produce a\n   * value that can be sent in a message, consisting of structured-cloneable\n   * values and/or transferrable objects.\n   */\n  serialize(value: T): [S, Transferable[]];\n\n  /**\n   * Gets called to deserialize an incoming value that was serialized in the\n   * other thread with this transfer handler (known through the name it was\n   * registered under).\n   */\n  deserialize(value: S): T;\n}\n\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler: TransferHandler<object, MessagePort> = {\n  canHandle: (val): val is ProxyMarked =>\n    isObject(val) && (val as ProxyMarked)[proxyMarker],\n  serialize(obj) {\n    const { port1, port2 } = new MessageChannel();\n    expose(obj, port1);\n    return [port2, [port2]];\n  },\n  deserialize(port) {\n    port.start();\n    return wrap(port);\n  },\n};\n\ninterface ThrownValue {\n  [throwMarker]: unknown; // just needs to be present\n  value: unknown;\n}\ntype SerializedThrownValue =\n  | { isError: true; value: Error }\n  | { isError: false; value: unknown };\n\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler: TransferHandler<\n  ThrownValue,\n  SerializedThrownValue\n> = {\n  canHandle: (value): value is ThrownValue =>\n    isObject(value) && throwMarker in value,\n  serialize({ value }) {\n    let serialized: SerializedThrownValue;\n    if (value instanceof Error) {\n      serialized = {\n        isError: true,\n        value: {\n          message: value.message,\n          name: value.name,\n          stack: value.stack,\n        },\n      };\n    } else {\n      serialized = { isError: false, value };\n    }\n    return [serialized, []];\n  },\n  deserialize(serialized) {\n    if (serialized.isError) {\n      throw Object.assign(\n        new Error(serialized.value.message),\n        serialized.value\n      );\n    }\n    throw serialized.value;\n  },\n};\n\n/**\n * Allows customizing the serialization of certain values.\n */\nexport const transferHandlers = new Map<\n  string,\n  TransferHandler<unknown, unknown>\n>([\n  [\"proxy\", proxyTransferHandler],\n  [\"throw\", throwTransferHandler],\n]);\n\nexport function expose(obj: any, ep: Endpoint = self as any) {\n  ep.addEventListener(\"message\", function callback(ev: MessageEvent) {\n    if (!ev || !ev.data) {\n      return;\n    }\n    const { id, type, path } = {\n      path: [] as string[],\n      ...(ev.data as Message),\n    };\n    const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n    let returnValue;\n    try {\n      const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n      const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n      switch (type) {\n        case MessageType.GET:\n          {\n            returnValue = rawValue;\n          }\n          break;\n        case MessageType.SET:\n          {\n            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n            returnValue = true;\n          }\n          break;\n        case MessageType.APPLY:\n          {\n            returnValue = rawValue.apply(parent, argumentList);\n          }\n          break;\n        case MessageType.CONSTRUCT:\n          {\n            const value = new rawValue(...argumentList);\n            returnValue = proxy(value);\n          }\n          break;\n        case MessageType.ENDPOINT:\n          {\n            const { port1, port2 } = new MessageChannel();\n            expose(obj, port2);\n            returnValue = transfer(port1, [port1]);\n          }\n          break;\n        case MessageType.RELEASE:\n          {\n            returnValue = undefined;\n          }\n          break;\n        default:\n          return;\n      }\n    } catch (value) {\n      returnValue = { value, [throwMarker]: 0 };\n    }\n    Promise.resolve(returnValue)\n      .catch((value) => {\n        return { value, [throwMarker]: 0 };\n      })\n      .then((returnValue) => {\n        const [wireValue, transferables] = toWireValue(returnValue);\n        ep.postMessage({ ...wireValue, id }, transferables);\n        if (type === MessageType.RELEASE) {\n          // detach and deactive after sending release response above.\n          ep.removeEventListener(\"message\", callback as any);\n          closeEndPoint(ep);\n        }\n      });\n  } as any);\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint: Endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nexport function wrap<T>(ep: Endpoint, target?: any): Remote<T> {\n  return createProxy<T>(ep, [], target) as any;\n}\n\nfunction throwIfProxyReleased(isReleased: boolean) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not useable\");\n  }\n}\n\nfunction createProxy<T>(\n  ep: Endpoint,\n  path: (string | number | symbol)[] = [],\n  target: object = function () {}\n): Remote<T> {\n  let isProxyReleased = false;\n  const proxy = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n      if (prop === releaseProxy) {\n        return () => {\n          return requestResponseMessage(ep, {\n            type: MessageType.RELEASE,\n            path: path.map((p) => p.toString()),\n          }).then(() => {\n            closeEndPoint(ep);\n            isProxyReleased = true;\n          });\n        };\n      }\n      if (prop === \"then\") {\n        if (path.length === 0) {\n          return { then: () => proxy };\n        }\n        const r = requestResponseMessage(ep, {\n          type: MessageType.GET,\n          path: path.map((p) => p.toString()),\n        }).then(fromWireValue);\n        return r.then.bind(r);\n      }\n      return createProxy(ep, [...path, prop]);\n    },\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased);\n      // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n      const [value, transferables] = toWireValue(rawValue);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.SET,\n          path: [...path, prop].map((p) => p.toString()),\n          value,\n        },\n        transferables\n      ).then(fromWireValue) as any;\n    },\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n      if ((last as any) === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: MessageType.ENDPOINT,\n        }).then(fromWireValue);\n      }\n      // We just pretend that `bind()` didn’t happen.\n      if (last === \"bind\") {\n        return createProxy(ep, path.slice(0, -1));\n      }\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.APPLY,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.CONSTRUCT,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n  });\n  return proxy as any;\n}\n\nfunction myFlat<T>(arr: (T | T[])[]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(argumentList: any[]): [WireValue[], Transferable[]] {\n  const processed = argumentList.map(toWireValue);\n  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\n\nconst transferCache = new WeakMap<any, Transferable[]>();\nexport function transfer<T>(obj: T, transfers: Transferable[]): T {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nexport function proxy<T>(obj: T): T & ProxyMarked {\n  return Object.assign(obj, { [proxyMarker]: true }) as any;\n}\n\nexport function windowEndpoint(\n  w: PostMessageWithOrigin,\n  context: EventSource = self,\n  targetOrigin = \"*\"\n): Endpoint {\n  return {\n    postMessage: (msg: any, transferables: Transferable[]) =>\n      w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context),\n  };\n}\n\nfunction toWireValue(value: any): [WireValue, Transferable[]] {\n  for (const [name, handler] of transferHandlers) {\n    if (handler.canHandle(value)) {\n      const [serializedValue, transferables] = handler.serialize(value);\n      return [\n        {\n          type: WireValueType.HANDLER,\n          name,\n          value: serializedValue,\n        },\n        transferables,\n      ];\n    }\n  }\n  return [\n    {\n      type: WireValueType.RAW,\n      value,\n    },\n    transferCache.get(value) || [],\n  ];\n}\n\nfunction fromWireValue(value: WireValue): any {\n  switch (value.type) {\n    case WireValueType.HANDLER:\n      return transferHandlers.get(value.name)!.deserialize(value.value);\n    case WireValueType.RAW:\n      return value.value;\n  }\n}\n\nfunction requestResponseMessage(\n  ep: Endpoint,\n  msg: Message,\n  transfers?: Transferable[]\n): Promise<WireValue> {\n  return new Promise((resolve) => {\n    const id = generateUUID();\n    ep.addEventListener(\"message\", function l(ev: MessageEvent) {\n      if (!ev.data || !ev.data.id || ev.data.id !== id) {\n        return;\n      }\n      ep.removeEventListener(\"message\", l as any);\n      resolve(ev.data);\n    } as any);\n    if (ep.start) {\n      ep.start();\n    }\n    ep.postMessage({ id, ...msg }, transfers);\n  });\n}\n\nfunction generateUUID(): string {\n  return new Array(4)\n    .fill(0)\n    .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n    .join(\"-\");\n}\n","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import defineProperty from \"./defineProperty.js\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}","import { Application, Expression, Lambda, Name, Program } from \"./parser/types\";\n\nexport function mangleName(n: Name): string {\n    return `${n.val}|${n.boundName}`;\n}\n\n/**\n * Get the next available name for a variable that is distinct from all (mangled) names in `existingMangledNames`\n */\nfunction getNextUnusedName(n: Name, existingMangledNames: Set<string>): Name {\n    if (!existingMangledNames.has(mangleName(n))) {\n        return n;\n    }\n    const ret: Name = { ...n, boundName: n.boundName ?? 1 };\n    while (existingMangledNames.has(mangleName(ret))) {\n        ret.boundName! += 1;\n    }\n\n    return ret;\n}\n\n/**\n * Rename all variables so that they have unique names. Free variables are not renamed and name collisions\n * with free variables are avoided.\n */\nexport function deShadowNames<T extends Program>(prog: T): T {\n    if (prog.type === \"empty_program\") {\n        return prog;\n    }\n\n    const currentlyBound: string[] = [];\n    const currentRenameMap: Record<string, Name[]> = {};\n    const freeVars = getFreeVariables(prog);\n    const usedNames: Set<string> = new Set(freeVars.map((v) => mangleName(v)));\n\n    function walk<S extends Expression>(expr: S): S {\n        switch (expr.type) {\n            case \"name\": {\n                const mangled = mangleName(expr);\n                // A name that is currently bound gets renamed as per the existing mapping.\n                // If a variable is currently bound, it should have a valid renaming.\n                if (currentlyBound.includes(mangled)) {\n                    const renameList = currentRenameMap[mangled] ?? [];\n                    const name = renameList[renameList.length - 1];\n                    if (name == null) {\n                        throw new Error(\n                            `The var with mangled name ${mangled} is listed as a bound variable, by entry in the rename map for it was found.`\n                        );\n                    }\n                    return { ...name } as S;\n                }\n                return expr;\n            }\n            case \"lambda\": {\n                const mangled = mangleName(expr.var);\n                currentlyBound.push(mangled);\n                // We set up a rename map so that any sub-occurrences of this name get renamed appropriately.\n                const newName = getNextUnusedName(expr.var, usedNames);\n                usedNames.add(mangleName(newName));\n                currentRenameMap[mangled] = currentRenameMap[mangled] || [];\n                currentRenameMap[mangled].push(newName);\n\n                const ret: Lambda = {\n                    type: \"lambda\",\n                    var: newName,\n                    body: walk(expr.body),\n                };\n\n                currentRenameMap[mangled].pop();\n                currentlyBound.pop();\n                return ret as S;\n            }\n            case \"application\": {\n                const ret: Application = {\n                    type: \"application\",\n                    body: expr.body.map((p) => walk(p)),\n                };\n                return ret as S;\n            }\n        }\n    }\n\n    return walk(prog) as T;\n}\n\nexport function getFreeVariables(prog: Program): Name[] {\n    if (prog.type === \"empty_program\") {\n        return [];\n    }\n\n    const ret: Name[] = [];\n    const retMangled: Set<string> = new Set();\n    const currentlyBound: string[] = [];\n\n    function walk(expr: Expression) {\n        switch (expr.type) {\n            case \"name\": {\n                const mangled = mangleName(expr);\n                // A name that is not bound and is not already in the free-vars list gets added to the list.\n                if (\n                    !currentlyBound.includes(mangled) &&\n                    !retMangled.has(mangled)\n                ) {\n                    ret.push(expr);\n                    retMangled.add(mangled);\n                }\n                return;\n            }\n            case \"lambda\":\n                currentlyBound.push(mangleName(expr.var));\n                walk(expr.body);\n                currentlyBound.pop();\n                return;\n            case \"application\":\n                expr.body.forEach((p) => walk(p));\n                return;\n        }\n    }\n\n    walk(prog);\n\n    return ret;\n}\n\n/**\n * Rename all variables so that they have unique names starting from the provided index.\n * By default, all variables are renamed `t`.\n * Free variables are not renamed and name collisions with free variables are avoided.\n */\nexport function canonicalRename<T extends Program>(\n    prog: T,\n    settings: { replaceNameWithT?: boolean; startIndex?: number } = {}\n): T {\n    if (prog.type === \"empty_program\") {\n        return prog;\n    }\n    const { replaceNameWithT = true, startIndex = 1 } = settings;\n\n    const currentlyBound: string[] = [];\n    const currentRenameMap: Record<string, Name[]> = {};\n    const freeVars = getFreeVariables(prog);\n    const usedNames: Set<string> = new Set(freeVars.map((v) => mangleName(v)));\n\n    let currentVarIndex = startIndex;\n\n    function walk<S extends Expression>(expr: S): S {\n        switch (expr.type) {\n            case \"name\": {\n                const mangled = mangleName(expr);\n                // A name that is currently bound gets renamed as per the existing mapping.\n                // If a variable is currently bound, it should have a valid renaming.\n                if (currentlyBound.includes(mangled)) {\n                    const renameList = currentRenameMap[mangled] ?? [];\n                    const name = renameList[renameList.length - 1];\n                    if (name == null) {\n                        throw new Error(\n                            `The var with mangled name ${mangled} is listed as a bound variable, by entry in the rename map for it was found.`\n                        );\n                    }\n                    return { ...name } as S;\n                }\n                return expr;\n            }\n            case \"lambda\": {\n                const mangled = mangleName(expr.var);\n                currentlyBound.push(mangled);\n                // We set up a rename map so that any sub-occurrences of this name get renamed appropriately.\n                const newName = getNextUnusedName(\n                    {\n                        type: \"name\",\n                        val: replaceNameWithT ? \"t\" : expr.var.val,\n                        boundName: currentVarIndex,\n                    },\n                    usedNames\n                );\n                usedNames.add(mangleName(newName));\n                currentRenameMap[mangled] = currentRenameMap[mangled] || [];\n                currentRenameMap[mangled].push(newName);\n                currentVarIndex++;\n\n                const ret: Lambda = {\n                    type: \"lambda\",\n                    var: newName,\n                    body: walk(expr.body),\n                };\n\n                currentRenameMap[mangled].pop();\n                currentlyBound.pop();\n                return ret as S;\n            }\n            case \"application\": {\n                const ret: Application = {\n                    type: \"application\",\n                    body: expr.body.map((p) => walk(p)),\n                };\n                return ret as S;\n            }\n        }\n    }\n\n    return walk(prog) as T;\n}\n","import { canonicalRename, deShadowNames } from \"./deshadow\";\nimport { Expression, Lambda, Name, Program } from \"./parser/types\";\n\nconst UNICODE_SUBSCRIPT = \"₀₁₂₃₄₅₆₇₈₉\".split(\"\");\n/**\n * Prints a number as subscript unicode characters.\n */\nfunction printSubscript(n: number): string {\n    return String(n)\n        .split(\"\")\n        .map((d) => {\n            const di = Number(d);\n            if (di >= 0) {\n                return UNICODE_SUBSCRIPT[di];\n            }\n            throw new Error(\n                `This function can only be used to print integers, not \"${d}\"`\n            );\n        })\n        .join(\"\");\n}\n\n/**\n * Print a program to a string making no effort to ensure it will parse again to the same program\n * (i.e., some variables will clash may.)\n */\nexport function printDirect(prog: Program): string {\n    switch (prog.type) {\n        case \"empty_program\":\n            return \"\";\n        case \"name\":\n            return prog.val;\n        case \"application\":\n            return prog.body\n                .map((p) => {\n                    const body = printDirect(p);\n                    if (p.type === \"lambda\" || p.type === \"application\") {\n                        return `(${body})`;\n                    }\n                    return body;\n                })\n                .join(\" \");\n        case \"lambda\":\n            return `λ${printDirect(prog.var)}.${printDirect(prog.body)}`;\n    }\n}\n\n/**\n * Return the variables in a program in the order that they occur. Free variables\n * are always listed. Bound variables are only listed the first time they occur.\n */\nexport function getVars(prog: Program): Name[] {\n    if (prog.type === \"empty_program\") {\n        return [];\n    }\n\n    const boundVars: Set<number | undefined> = new Set();\n\n    // First we get all the bound vars. Since we may be parsing a sub expression,\n    // we cannot rely on `boundName` to determine if a var is free or not.\n    function getBoundVars(expr: Expression) {\n        switch (expr.type) {\n            case \"name\":\n                break;\n            case \"lambda\":\n                if (expr.var.boundName) {\n                    boundVars.add(expr.var.boundName);\n                }\n                getBoundVars(expr.body);\n                break;\n            case \"application\":\n                if (Array.isArray(expr.body)) {\n                    expr.body.forEach((e) => getBoundVars(e));\n                } else {\n                    getBoundVars(expr);\n                }\n        }\n    }\n    getBoundVars(prog);\n\n    function _getVars(expr: Expression): Name[] {\n        switch (expr.type) {\n            case \"name\":\n                if (expr.boundName == null || !boundVars.has(expr.boundName)) {\n                    // In this case, we have a free variable, which is always returned\n                    return [{ ...expr, freeInScope: true }];\n                }\n                return [];\n            case \"lambda\":\n                return [expr.var].concat(_getVars(expr.body));\n            case \"application\":\n                return expr.body\n                    .filter(\n                        (p) => p.type !== \"name\" || !boundVars.has(p.boundName)\n                    )\n                    .flatMap((p) => _getVars(p));\n        }\n    }\n    return _getVars(prog);\n}\n\n/**\n * Print the program. All bound variables are given unique subscripts.\n */\nexport function print(prog: Program): string {\n    switch (prog.type) {\n        case \"empty_program\":\n            return \"\";\n        case \"name\":\n            return printNameWithSubscript(prog);\n        case \"lambda\":\n            return `λ${print(prog.var)}.${print(prog.body)}`;\n        case \"application\":\n            return prog.body\n                .map((p) => {\n                    const body = print(p);\n                    if (p.type === \"lambda\" || p.type === \"application\") {\n                        return `(${body})`;\n                    }\n                    return body;\n                })\n                .join(\" \");\n    }\n}\n\nfunction printNameWithSubscript(n: Name): string {\n    return n.boundName != null\n        ? n.val + printSubscript(Number(n.boundName))\n        : n.val;\n}\n\n/**\n * Prints a `Name` object in a non-ambiguous way.\n */\nfunction printMangledName(n: Name): string {\n    return `${n.val}|${n.boundName}`;\n}\n\n/**\n * Find the next unused name by taking the base name an applying subscripts if needed.\n */\nfunction getNextUnusedName(n: Name, usedNames: Set<string>): string {\n    let i = 0;\n    let newName: Name = {\n        type: \"name\",\n        val: n.val,\n        boundName: undefined,\n    };\n    while (usedNames.has(printNameWithSubscript(newName))) {\n        i++;\n        newName.boundName = i;\n    }\n    return printNameWithSubscript(newName);\n}\n\n/**\n * Print a program with a minimal amount of variable renaming (only what is required to keep variable names from clashing).\n */\nexport function printMinimal(prog: Program): string {\n    if (prog.type === \"empty_program\") {\n        return \"\";\n    }\n\n    // Free variables should keep their names\n    const freeVars = getVars(prog).filter((v) => v.freeInScope === true);\n\n    function _printMinimal(\n        expr: Expression,\n        state: {\n            usedInScope: Set<string>;\n            renameMap: Map<string, string>;\n        }\n    ): string {\n        switch (expr.type) {\n            case \"name\": {\n                const mangledName = printMangledName(expr);\n                let desiredName = state.renameMap.get(mangledName);\n                if (desiredName) {\n                    return desiredName;\n                }\n                // If we have aren't in the rename map, we are a free variable.\n                // In that case, we need to pick a unique name and also save that name in case we come up again in the future.\n                desiredName = getNextUnusedName(expr, state.usedInScope);\n                state.usedInScope.add(desiredName);\n                state.renameMap.set(mangledName, desiredName);\n                return desiredName;\n            }\n            case \"lambda\": {\n                // The variable of a lambda expression should be made clearly different\n                // in cases where it is strictly not necessary. For example `\\x.\\x.x` should\n                // become `\\x.\\x1.x1` even thought it is not strictly necessary.\n                const mangledName = printMangledName(expr.var);\n                const targetName = getNextUnusedName(\n                    expr.var,\n                    state.usedInScope\n                );\n                state.usedInScope.add(targetName);\n                state.renameMap.set(mangledName, targetName);\n                const ret = `λ${_printMinimal(expr.var, state)}.${_printMinimal(\n                    expr.body,\n                    state\n                )}`;\n                state.usedInScope.delete(targetName);\n                state.renameMap.delete(mangledName);\n                return ret;\n            }\n            case \"application\":\n                return expr.body\n                    .map((p) => {\n                        const body = _printMinimal(p, state);\n                        if (p.type === \"lambda\" || p.type === \"application\") {\n                            return `(${body})`;\n                        }\n                        return body;\n                    })\n                    .join(\" \");\n        }\n    }\n\n    return _printMinimal(prog, {\n        usedInScope: new Set(freeVars.map((v) => v.val)),\n        renameMap: new Map(freeVars.map((v) => [printMangledName(v), v.val])),\n    });\n}\n\n/**\n * Print a program in a canonical form. If two programs are structurally equal, their\n * canonical prints will be the same.\n */\nexport function canonicalPrint(prog: Program): string {\n    if (prog.type === \"empty_program\") {\n        return \"\";\n    }\n\n    prog = canonicalRename(prog) as Expression;\n    return print(prog);\n}\n\nexport { canonicalRename };\n","import { canonicalRename } from \"./deshadow\";\nimport { Expression, Lambda, Name, Program } from \"./parser/types\";\nimport { canonicalPrint,  print } from \"./printer\";\n\n/**\n * Run `prog` until termination.\n */\nexport function evaluate(prog: Program): Program {\n    switch (prog.type) {\n        case \"name\":\n        case \"empty_program\":\n            return prog;\n        case \"lambda\":\n            return {\n                type: \"lambda\",\n                var: prog.var,\n                body: evaluate(prog.body) as Expression,\n            };\n        case \"application\":\n            if (prog.body.length === 0) {\n                throw new Error(`Cannot evaluate an empty body`);\n            }\n            if (prog.body.length === 1) {\n                return evaluate(prog.body[0]);\n            }\n            // There are at least two things to evaluate. We work right-recursively\n            // and stop as soon as we encounter a non-lambda expression.\n            const func = prog.body[0];\n            const arg = prog.body[1];\n            switch (func.type) {\n                case \"name\":\n                    // We don't start with something that can be evaluated, so we go the \"next level down\"\n                    // and see if any children can be further evaluated.\n                    return {\n                        type: \"application\",\n                        body: prog.body.map((p) => evaluate(p) as Expression),\n                    };\n                case \"lambda\":\n                    // Evaluate the right-most expression and recurse\n                    return evaluate({\n                        type: \"application\",\n                        body: [\n                            replaceVar(func.body, func.var, arg),\n                            ...prog.body.slice(2),\n                        ],\n                    });\n                case \"application\":\n                    const before = canonicalPrint(func);\n                    const evaluatedFunc = evaluate(func);\n                    const after = canonicalPrint(evaluatedFunc);\n                    // If the value of the application didn't change after\n                    // evaluating it, we don't want to recursively call the evaluate function again.\n                    // This can happen, for example, if there are free variables in `func` such that\n                    // `func` doesn't change. E.g.: `(a b) c`. Upon evaluating `(a b)`, the result is still `(a b)`.\n                    if (before === after) {\n                        return {\n                            type: \"application\",\n                            body: [\n                                evaluate(func) as Expression,\n                                arg,\n                                ...prog.body.slice(2),\n                            ],\n                        };\n                    }\n                    return evaluate({\n                        type: \"application\",\n                        body: [\n                            evaluate(func) as Expression,\n                            arg,\n                            ...prog.body.slice(2),\n                        ],\n                    });\n            }\n    }\n}\n\n/**\n * Replace all instances of `oldVar` in `prog` with that of `newVal`.\n *\n * **Note**: It is assumed that `oldVar` does not appear as the variable in a lambda expression.\n */\nfunction replaceVar(\n    prog: Expression,\n    oldVar: Name,\n    newVal: Expression\n): Expression {\n    function nameMatches(name: Expression) {\n        if (name.type !== \"name\") {\n            return false;\n        }\n        return name.val === oldVar.val && name.boundName === oldVar.boundName;\n    }\n    let largestIndex = largestVarIndex(prog);\n    //console.log(\n    //    print(oldVar),\n    //    print(prog),\n    //    print(\n    //        canonicalRename(prog, { replaceNameWithT: false, startIndex: 10 })\n    //    )\n    //);\n\n    function _replaceVar(prog: Expression) {\n        switch (prog.type) {\n            case \"name\":\n                if (nameMatches(prog)) {\n                    const ret = canonicalRename(newVal, {\n                        replaceNameWithT: false,\n                        startIndex: largestIndex,\n                    }) as Expression;\n                    largestIndex = Math.max(largestIndex, largestVarIndex(ret));\n                    return ret;\n                } else {\n                    return prog;\n                }\n            case \"lambda\": {\n                if (nameMatches(prog.var)) {\n                    throw new Error(\n                        `Cannot replace variable ${print(\n                            oldVar\n                        )} since it appears as the variable name in the lambda ${print(\n                            prog\n                        )}`\n                    );\n                }\n                const ret = canonicalRename(\n                    { ...prog, body: _replaceVar(prog.body) },\n                    {\n                        replaceNameWithT: false,\n                        startIndex: largestIndex,\n                    }\n                ) as Expression;\n                largestIndex = Math.max(largestIndex, largestVarIndex(ret));\n                return ret;\n            }\n            case \"application\": {\n                const ret = canonicalRename(\n                    {\n                        type: \"application\",\n                        body: prog.body.map((p) => _replaceVar(p)),\n                    },\n                    {\n                        replaceNameWithT: false,\n                        startIndex: largestIndex,\n                    }\n                ) as Expression;\n                largestIndex = Math.max(largestIndex, largestVarIndex(ret));\n                return ret;\n            }\n        }\n    }\n\n    return _replaceVar(prog);\n}\n\n/**\n * Get the largest index of a variable used inside of the program.\n */\nfunction largestVarIndex(prog: Program): number {\n    switch (prog.type) {\n        case \"empty_program\":\n            return 0;\n        case \"name\":\n            return prog.boundName || 0;\n        case \"lambda\":\n            return Math.max(\n                largestVarIndex(prog.var),\n                largestVarIndex(prog.body)\n            );\n        case \"application\":\n            if (Array.isArray(prog.body)) {\n                return Math.max(...prog.body.map((p) => largestVarIndex(p)));\n            }\n            return largestVarIndex(prog.body);\n    }\n}\n","export default // Generated by Peggy 2.0.1.\n//\n// https://peggyjs.org/\n(function() {\n  \"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  var self = Error.call(this, message);\n  // istanbul ignore next Check is a necessary evil to support older environments\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n  }\n  self.expected = expected;\n  self.found = found;\n  self.location = location;\n  self.name = \"SyntaxError\";\n  return self;\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$padEnd(str, targetLength, padString) {\n  padString = padString || \" \";\n  if (str.length > targetLength) { return str; }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\npeg$SyntaxError.prototype.format = function(sources) {\n  var str = \"Error: \" + this.message;\n  if (this.location) {\n    var src = null;\n    var k;\n    for (k = 0; k < sources.length; k++) {\n      if (sources[k].source === this.location.source) {\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n        break;\n      }\n    }\n    var s = this.location.start;\n    var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n    if (src) {\n      var e = this.location.end;\n      var filler = peg$padEnd(\"\", s.line.toString().length, ' ');\n      var line = src[s.line - 1];\n      var last = s.line === e.line ? e.column : line.length + 1;\n      var hatLen = (last - s.column) || 1;\n      str += \"\\n --> \" + loc + \"\\n\"\n          + filler + \" |\\n\"\n          + s.line + \" | \" + line + \"\\n\"\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1, ' ')\n          + peg$padEnd(\"\", hatLen, \"^\");\n    } else {\n      str += \"\\n at \" + loc;\n    }\n  }\n  return str;\n};\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n  var peg$source = options.grammarSource;\n\n  var peg$startRuleFunctions = { program: peg$parseprogram };\n  var peg$startRuleFunction = peg$parseprogram;\n\n  var peg$c0 = \"(\";\n  var peg$c1 = \")\";\n  var peg$c2 = \".\";\n  var peg$c3 = \"\\\\\";\n  var peg$c4 = \"\\u03BB\";\n  var peg$c5 = \"lambda\";\n  var peg$c6 = \"//\";\n  var peg$c7 = \"\\n\";\n\n  var peg$r0 = /^[ \\t\\n\\r]/;\n  var peg$r1 = /^[a-zA-Z0-9_]/;\n  var peg$r2 = /^[\\u2080\\u2081\\u2082\\u2083\\u2084\\u2085\\u2086\\u2087\\u2088\\u2089]/;\n  var peg$r3 = /^[ \\t]/;\n\n  var peg$e0 = peg$otherExpectation(\"program\");\n  var peg$e1 = peg$otherExpectation(\"expression\");\n  var peg$e2 = peg$otherExpectation(\"application\");\n  var peg$e3 = peg$literalExpectation(\"(\", false);\n  var peg$e4 = peg$literalExpectation(\")\", false);\n  var peg$e5 = peg$otherExpectation(\"inner_function\");\n  var peg$e6 = peg$literalExpectation(\".\", false);\n  var peg$e7 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false);\n  var peg$e8 = peg$otherExpectation(\"name\");\n  var peg$e9 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \"_\"], false, false);\n  var peg$e10 = peg$classExpectation([\"\\u2080\", \"\\u2081\", \"\\u2082\", \"\\u2083\", \"\\u2084\", \"\\u2085\", \"\\u2086\", \"\\u2087\", \"\\u2088\", \"\\u2089\"], false, false);\n  var peg$e11 = peg$otherExpectation(\"lambda\");\n  var peg$e12 = peg$literalExpectation(\"\\\\\", false);\n  var peg$e13 = peg$literalExpectation(\"\\u03BB\", false);\n  var peg$e14 = peg$literalExpectation(\"lambda\", false);\n  var peg$e15 = peg$otherExpectation(\"comment_or_whitespace\");\n  var peg$e16 = peg$otherExpectation(\"whitespace\");\n  var peg$e17 = peg$otherExpectation(\"comment\");\n  var peg$e18 = peg$classExpectation([\" \", \"\\t\"], false, false);\n  var peg$e19 = peg$literalExpectation(\"//\", false);\n  var peg$e20 = peg$anyExpectation();\n  var peg$e21 = peg$literalExpectation(\"\\n\", false);\n\n  var peg$f0 = function(e) { return e; };\n  var peg$f1 = function() { return undefined; };\n  var peg$f2 = function(a) { return a; };\n  var peg$f3 = function(e, p) { return [p]; };\n  var peg$f4 = function(e, n) { return n; };\n  var peg$f5 = function(e, rest) { return [e].concat(...rest); };\n  var peg$f6 = function(f) { return f; };\n  var peg$f7 = function(v, expr) {\n            return { type: \"lambda\", var: v, body: expr };\n        };\n  var peg$f8 = function(n) { return n; };\n  var peg$f9 = function(c) { return !\"\\n\\r\".includes(c); };\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$maxFailPos = 0;\n  var peg$maxFailExpected = [];\n  var peg$silentFails = 0;\n\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return {\n      source: peg$source,\n      start: peg$savedPos,\n      end: peg$currPos\n    };\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n\n    return {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parseprogram() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseexpression();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f0(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseEOF();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f1();\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseexpression() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$parseapplication();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsefunction();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsename();\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e1); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseapplication() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$parseinner_application();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseparen_application();\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseparen_application() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 40) {\n      s1 = peg$c0;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseinner_application();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 41) {\n          s3 = peg$c1;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e4); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f2(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseinner_application() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsefunction();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsename();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseparen_application();\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$currPos;\n            s8 = peg$parseparen_application();\n            if (s8 !== peg$FAILED) {\n              peg$savedPos = s7;\n              s8 = peg$f3(s2, s8);\n            }\n            s7 = s8;\n            if (s7 === peg$FAILED) {\n              s7 = peg$parseexpression();\n            }\n            if (s7 !== peg$FAILED) {\n              peg$savedPos = s5;\n              s5 = peg$f4(s2, s7);\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$currPos;\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$currPos;\n                s8 = peg$parseparen_application();\n                if (s8 !== peg$FAILED) {\n                  peg$savedPos = s7;\n                  s8 = peg$f3(s2, s8);\n                }\n                s7 = s8;\n                if (s7 === peg$FAILED) {\n                  s7 = peg$parseexpression();\n                }\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s5;\n                  s5 = peg$f4(s2, s7);\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            }\n          } else {\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse_();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f5(s2, s4);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefunction() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$parseinner_function();\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s1 = peg$c0;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e3); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsefunction();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c1;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e4); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f6(s3);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseinner_function() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parselambda();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsename();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parse_();\n          if (s5 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s6 = peg$c2;\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e6); }\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parse_();\n              if (s7 !== peg$FAILED) {\n                s5 = [s5, s6, s7];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 === peg$FAILED) {\n            s4 = [];\n            if (peg$r0.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e7); }\n            }\n            if (s5 !== peg$FAILED) {\n              while (s5 !== peg$FAILED) {\n                s4.push(s5);\n                if (peg$r0.test(input.charAt(peg$currPos))) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e7); }\n                }\n              }\n            } else {\n              s4 = peg$FAILED;\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse_();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseexpression();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parse_();\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s0 = peg$f7(s3, s6);\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e5); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsename() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$parseinner_name();\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s1 = peg$c0;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e3); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsename();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c1;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e4); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f8(s3);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseinner_name() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    s3 = [];\n    if (peg$r1.test(input.charAt(peg$currPos))) {\n      s4 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s4 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e9); }\n    }\n    if (s4 !== peg$FAILED) {\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        if (peg$r1.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e9); }\n        }\n      }\n    } else {\n      s3 = peg$FAILED;\n    }\n    if (s3 !== peg$FAILED) {\n      s2 = input.substring(s2, peg$currPos);\n    } else {\n      s2 = s3;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$currPos;\n      s4 = [];\n      if (peg$r2.test(input.charAt(peg$currPos))) {\n        s5 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e10); }\n      }\n      if (s5 !== peg$FAILED) {\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          if (peg$r2.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e10); }\n          }\n        }\n      } else {\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s3 = input.substring(s3, peg$currPos);\n      } else {\n        s3 = s4;\n      }\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      s2 = [s2, s3];\n      s1 = s2;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e8); }\n    }\n\n    return s0;\n  }\n\n  function peg$parselambda() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 92) {\n      s0 = peg$c3;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e12); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 955) {\n        s0 = peg$c4;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e13); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 6) === peg$c5) {\n          s0 = peg$c5;\n          peg$currPos += 6;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e14); }\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e11); }\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$parsecomment();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsews();\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e15); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsews() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = [];\n    if (peg$r0.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e7); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$r0.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e7); }\n      }\n    }\n    peg$silentFails--;\n    s1 = peg$FAILED;\n    if (peg$silentFails === 0) { peg$fail(peg$e16); }\n\n    return s0;\n  }\n\n  function peg$parsecomment() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$r3.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e18); }\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      if (peg$r3.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e18); }\n      }\n    }\n    if (input.substr(peg$currPos, 2) === peg$c6) {\n      s2 = peg$c6;\n      peg$currPos += 2;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e19); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = [];\n      s4 = peg$currPos;\n      if (input.length > peg$currPos) {\n        s5 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e20); }\n      }\n      if (s5 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s6 = peg$f9(s5);\n        if (s6) {\n          s6 = undefined;\n        } else {\n          s6 = peg$FAILED;\n        }\n        if (s6 !== peg$FAILED) {\n          s5 = [s5, s6];\n          s4 = s5;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$currPos;\n        if (input.length > peg$currPos) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e20); }\n        }\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s6 = peg$f9(s5);\n          if (s6) {\n            s6 = undefined;\n          } else {\n            s6 = peg$FAILED;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n      }\n      s4 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 10) {\n        s5 = peg$c7;\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e21); }\n      }\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parsews();\n        s7 = peg$parse_();\n        if (s7 !== peg$FAILED) {\n          s5 = [s5, s6, s7];\n          s4 = s5;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 === peg$FAILED) {\n        s4 = peg$parseEOF();\n      }\n      if (s4 !== peg$FAILED) {\n        s1 = [s1, s2, s3, s4];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e17); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseEOF() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    peg$silentFails++;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e20); }\n    }\n    peg$silentFails--;\n    if (s1 === peg$FAILED) {\n      s0 = undefined;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n})()\n","// This file needs to be here because typescript does not know how to use babel's transpiler\n// to directly load Pegjs grammars.\n// @ts-nocheck\nimport _LambdaCalcPegParser from \"./grammars/lambda-calc.pegjs\";\n\ntype PegParser = {\n    parse: (input: string | unknown[], options?: unknown) => any;\n    SyntaxError: (\n        message: string,\n        expected: string,\n        found: unknown,\n        location: unknown\n    ) => unknown;\n};\n\nconst LambdaCalcPegParser = _LambdaCalcPegParser as PegParser;\n\nexport { LambdaCalcPegParser };\n","import { LambdaCalcPegParser } from \"./parsers\";\nimport { BasicProgram, Expression, Lambda, Program } from \"./types\";\n\n/**\n * Parse a string into a basic program\n */\nexport function parseBasic(code: string) {\n    return LambdaCalcPegParser.parse(code) as BasicProgram;\n}\n\n/**\n * Convert a `BasicProgram` into a `Program`.\n */\nexport function basicProgramToProgram(basicProg: BasicProgram): Program {\n    if (basicProg == null) {\n        return { type: \"empty_program\" };\n    }\n    if (Array.isArray(basicProg)) {\n        if (basicProg.length === 0) {\n            throw new Error(`Expected an application to have 1 or more items`);\n        }\n        if (basicProg.length === 1) {\n            return basicProgramToProgram(basicProg[0]);\n        }\n        return {\n            type: \"application\",\n            body: basicProg.map((p) => basicProgramToProgram(p) as Expression),\n        };\n    }\n    if (typeof basicProg === \"string\") {\n        return { type: \"name\", val: basicProg };\n    }\n    if (basicProg.type === \"lambda\") {\n        return {\n            type: \"lambda\",\n            var: { type: \"name\", val: basicProg.var },\n            body: basicProgramToProgram(basicProg.body) as Expression,\n        };\n    }\n    throw new Error(\n        `Don't know how to convert program ${JSON.stringify(basicProg)}`\n    );\n}\n\n/**\n * Ensure all bound variables have unique names so that evaluation will not cause\n * any name collisions.\n */\nexport function bindProgramVars(\n    prog: Program,\n    boundVars: { vars: Record<string, number[]>; count: number } = {\n        vars: {},\n        count: 0,\n    }\n): Program {\n    switch (prog.type) {\n        case \"empty_program\":\n            return prog;\n        case \"name\":\n            if (prog.boundName != null) {\n                return prog;\n            } else {\n                const bound = boundVars.vars[prog.val];\n                if (bound && bound.length > 0) {\n                    const id = bound[bound.length - 1];\n                    return { ...prog, boundName: id };\n                } else {\n                    return prog;\n                }\n            }\n        case \"application\":\n            return {\n                type: \"application\",\n                body: prog.body.map(\n                    (x) => bindProgramVars(x, boundVars) as Expression\n                ),\n            };\n        case \"lambda\": {\n            boundVars.count++;\n            const varCount = boundVars.count;\n            boundVars.vars[prog.var.val] = boundVars.vars[prog.var.val] || [];\n            const boundStack = boundVars.vars[prog.var.val];\n            boundStack.push(varCount);\n            const ret: Lambda = {\n                type: \"lambda\",\n                var: { ...prog.var, boundName: varCount },\n                body: bindProgramVars(prog.body, boundVars) as Expression,\n            };\n            // Bound variables go in and out of scope, so make sure to remove the binding when\n            // we finish processing the lambda.\n            boundStack.pop();\n            return ret;\n        }\n    }\n    throw new Error(`Unknown program type ${JSON.stringify(prog)}`);\n}\n\n/**\n * Parse a string into a lambda calculus `Program`.\n */\nexport function parse(code: string): Program {\n    return bindProgramVars(basicProgramToProgram(parseBasic(code)));\n}\n","import * as Comlink from \"comlink\";\nimport { parse, evaluate } from \"lambda-calculus-interpreter\";\n\nconst exposed = {\n    parse: (s: string) => {\n        try {\n            return parse(s);\n        } catch (e: any) {\n            if (e.format) {\n                throw Object.assign(\n                    { desc: String(e), terminalDesc: e.format([{ text: s }]) },\n                    e\n                );\n            }\n            throw e;\n        }\n    },\n    evaluate,\n};\n\nexport type Exposed = typeof exposed;\n\n// We are exporting `void`, but we have to export _something_ to get the module to work correctly\nexport default Comlink.expose(exposed);\n"],"names":["_arrayLikeToArray","arr","len","length","i","arr2","Array","_unsupportedIterableToArray","o","minLen","n","Object","prototype","toString","call","slice","constructor","name","from","test","_slicedToArray","isArray","_i","Symbol","iterator","_s","_e","_arr","_n","_d","next","done","push","value","err","TypeError","_defineProperty","obj","key","defineProperty","enumerable","configurable","writable","_setPrototypeOf","p","setPrototypeOf","bind","__proto__","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","valueOf","e","_construct","Parent","args","Class","a","apply","instance","Function","arguments","_toConsumableArray","iter","proxyMarker","createEndpoint","releaseProxy","throwMarker","isObject","val","transferHandlers","Map","canHandle","serialize","MessageChannel","port1","port2","expose","deserialize","port","start","createProxy","target","Error","isError","message","stack","serialized","assign","ep","self","addEventListener","callback","ev","data","returnValue","path","id","type","argumentList","map","fromWireValue","parent","reduce","prop","rawValue","proxy","transfer","undefined","Promise","resolve","catch","then","toWireValue","wireValue","transferables","postMessage","removeEventListener","closeEndPoint","endpoint","isMessagePort","close","throwIfProxyReleased","isReleased","isProxyReleased","get","_target","requestResponseMessage","r","set","_thisArg","rawArgumentList","last","processArguments","processed","v","concat","transferCache","WeakMap","transfers","allowArrayLike","it","F","s","f","normalCompletion","didErr","step","_e2","handler","msg","fill","Math","floor","random","Number","MAX_SAFE_INTEGER","join","l","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","_objectSpread2","source","forEach","getOwnPropertyDescriptors","defineProperties","mangleName","boundName","getNextUnusedName","existingMangledNames","has","ret","getFreeVariables","prog","retMangled","Set","currentlyBound","walk","expr","mangled","includes","add","var","body","pop","canonicalRename","settings","replaceNameWithT","startIndex","currentRenameMap","freeVars","usedNames","currentVarIndex","renameList","newName","UNICODE_SUBSCRIPT","split","print","printNameWithSubscript","String","d","di","printSubscript","canonicalPrint","replaceVar","oldVar","newVal","nameMatches","largestIndex","largestVarIndex","_replaceVar","max","LambdaCalcPegParser","peg$SyntaxError","expected","found","location","this","peg$padEnd","str","targetLength","padString","repeat","child","C","peg$subclass","format","sources","k","src","text","loc","line","column","end","filler","hatLen","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","class","escapedParts","parts","part","classEscape","inverted","any","other","description","hex","ch","charCodeAt","toUpperCase","replace","describeExpectation","j","descriptions","sort","describeExpected","SyntaxError","parse","input","options","peg$result","peg$FAILED","peg$source","grammarSource","peg$startRuleFunctions","program","peg$parseprogram","peg$startRuleFunction","peg$c5","peg$c6","peg$r0","peg$r1","peg$r2","peg$r3","peg$e0","peg$otherExpectation","peg$e1","peg$e2","peg$e3","peg$literalExpectation","peg$e4","peg$e5","peg$e6","peg$e7","peg$classExpectation","peg$e8","peg$e9","peg$e10","peg$e11","peg$e12","peg$e13","peg$e14","peg$e15","peg$e16","peg$e17","peg$e18","peg$e19","peg$e20","peg$e21","peg$f3","peg$f4","peg$f9","c","peg$currPos","peg$posDetailsCache","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","startRule","ignoreCase","peg$computePosDetails","pos","details","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","offset","peg$fail","peg$buildStructuredError","s0","s2","peg$parse_","peg$parseexpression","peg$parseEOF","peg$f1","peg$parseinner_application","peg$parseparen_application","peg$parseapplication","peg$parsefunction","peg$parsename","s1","s3","s4","s5","s7","s8","rest","peg$f5","s6","substr","peg$parselambda","charAt","peg$parseinner_function","substring","peg$parseinner_name","peg$parsews","peg$parsecomment","basicProgramToProgram","basicProg","JSON","stringify","bindProgramVars","boundVars","vars","count","bound","x","varCount","boundStack","code","parseBasic","exposed","desc","terminalDesc","evaluate","func","arg","Comlink"],"sourceRoot":""}